# Dream3DForge

**Dream3DForge** is an advanced AI-powered architectural consulting and prototyping engine designed to build 3D web games instantly. It leverages Google's Gemini 3 models to separate game design (Blueprint) from implementation (Prototype), ensuring high-quality, structurally sound, and deterministic results.

## Core Architecture

Unlike generic code generators, Forge splits the development pipeline into two distinct phases to maximize stability and control:

1.  **Blueprint Phase (Architect)**: Generates a pure JSON specification of the game's mechanics, visual style, and system architecture. This can be reviewed and frozen before a single line of code is written.
2.  **Prototype Phase (Builder)**: Compiles the frozen blueprint into a playable Three.js/WebGL application, synthesizing shaders, logic, and procedural audio assets.

## Pro Features

### üîí Deterministic Seed Lock
Ensure reproducible builds by locking the random seed.
- **Seed Control**: Manually set or randomize the seed.
- **Lock Mode**: Prevents accidental regeneration, ensuring that "Refining" a game doesn't change its fundamental RNG layout.
- **Manifest**: Every export includes a `forge.manifest.json` tracking the seed, spec hash, and build hash.

### üîä Procedural Audio Synthesis
The engine creates a complete soundscape using the Web Audio API without external assets.
- **BGM**: Mathematically generated background loops using Oscillators and GainNodes.
- **SFX**: Synthesized sound effects linked to specific gameplay triggers (e.g., jump, shoot).

### üì¶ Full State Export
The export package now includes:
- `blueprint.json`: The complete raw JSON specification.
- `forge.manifest.json`: Versioning and cryptographic hashes for provenance.
- `index.html`: The standalone executable.

### üõ†Ô∏è Developer Extensibility
Dream3DForge is built to be extended:
- **Prompt Registry**: All AI prompts are centralized in `services/promptRegistry.ts` for easy tuning.
- **Provider Abstraction**: `services/client.ts` supports runtime swapping of AI providers (e.g., Local LLMs).
- **Versioning**: Strict semantic versioning ensures blueprint compatibility across updates.

### üõ°Ô∏è Live Telemetry & Safety
- **Kill Switch**: Instantly terminates the WebGL runtime/iframe if it freezes or causes performance issues.
- **Telemetry Overlay**: Real-time monitoring of FPS and Entity Count.
- **Sandboxed Execution**: Games run in a secure, isolated environment.

## Usage Guide

1.  **Configure Identity**: Select the Genre, Visual Style, Platform, and Difficulty.
2.  **Initialize Forge**: Click **Initialize Forge** to generate the Architectural Blueprint.
3.  **Review & Freeze**: detailed architecture diagram. Click **Approve & Freeze Spec** to commit to this design.
4.  **Compile Prototype**: The AI will generate the game code and audio assets.
5.  **Play & Refine**: Test the prototype. Use the **Iterate & Polish** panel to request specific changes (e.g., "Make the player move faster").
    - *Tip*: Open "Advanced Tuning" to adjust the AI's creativity during refinement.
6.  **Export**: Click **Export ZIP** to download the standalone HTML file, Manifest, and Documentation.

## Tech Stack

- **Frontend**: React 18, TailwindCSS, Framer Motion
- **AI**: @google/genai SDK (Gemini 3 Pro)
- **3D Engine**: Three.js (injected into prototypes)
- **Export**: JSZip

---
*Generated by Dream3DForge*